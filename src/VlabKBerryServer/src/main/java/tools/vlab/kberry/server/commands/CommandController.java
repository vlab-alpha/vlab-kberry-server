package tools.vlab.kberry.server.commands;

import io.netty.handler.codec.mqtt.MqttQoS;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.mqtt.MqttClient;
import io.vertx.mqtt.MqttClientOptions;
import io.vertx.mqtt.messages.MqttConnAckMessage;
import lombok.Getter;
import lombok.Setter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import tools.vlab.kberry.core.devices.KNXDevices;
import tools.vlab.kberry.server.logic.Logics;
import tools.vlab.kberry.server.scheduler.Schedule;
import tools.vlab.kberry.server.serviceProvider.ServiceProviders;
import tools.vlab.kberry.server.statistics.Statistics;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

public class CommandController extends AbstractVerticle {

    private static final Logger Log = LoggerFactory.getLogger(CommandController.class);

    private final String mqttHost;
    private final KNXDevices knxDevices;
    private final Statistics statistics;
    private final ServiceProviders serviceProviders;
    private final Schedule schedule;
    private final Logics logics;
    private List<Command> commandList = new ArrayList<>();
    @Setter
    @Getter
    private MqttClient client;
    private final int mqttPort;

    public CommandController(String mqttHost, int mqttPort, KNXDevices knxDevices, Statistics statistics, ServiceProviders serviceProviders, Schedule schedule, Logics logics) {
        this.mqttHost = mqttHost;
        this.knxDevices = knxDevices;
        this.statistics = statistics;
        this.serviceProviders = serviceProviders;
        this.schedule = schedule;
        this.logics = logics;
        this.mqttPort = mqttPort;
    }

    public void register(Command... commandList) {
        this.commandList = Stream.of(commandList)
                .peek(cmd -> cmd.setStatistics(statistics))
                .peek(cmd -> cmd.setKnxDevices(knxDevices))
                .peek(cmd -> cmd.setServiceProviders(serviceProviders))
                .peek(cmd -> cmd.setSchedule(schedule))
                .peek(cmd -> cmd.setLogics(logics))
                .peek(Command::init)
                .toList();
    }


    @Override
    public void start(Promise<Void> startPromise) {
        connectClient()
                .onSuccess(v -> {
                    subscribeCommands();
                    setupMessageHandler();
                    startPromise.complete();
                })
                .onFailure(startPromise::fail);
    }

    protected Future<MqttConnAckMessage> connectClient() {
        MqttClientOptions options = new MqttClientOptions()
                .setAutoGeneratedClientId(true)
                .setCleanSession(true);
        this.client = MqttClient.create(getVertx(), options); // <-- Client speichern
        return client.connect(mqttPort, mqttHost); // connect aufrufen
    }

    private void subscribeCommands() {
        for (Command command : this.commandList) {
            String topicRequest = "request/" + command.topic();
            this.client.subscribe(topicRequest, 0)
                    .onSuccess(handler -> {
                        System.out.println("Subscribed to: " + topicRequest);
                    })
                    .onFailure(cause -> System.err.println("Failed to subscribe to " + topicRequest + ": " + cause.getMessage()));
        }
    }

    private void setupMessageHandler() {
        client.publishHandler(message -> {
            String topic = message.topicName();
            if (!topic.startsWith("request/")) return;

            String topicCommand = topic.substring("request/".length());
            var payload = message.payload().toString();
            Log.debug("Received {} message: {}", topic, payload);
            JsonObject json = payload != null && !payload.isEmpty() ? new JsonObject(payload) : new JsonObject();
            for (Command command : commandList) {
                if (command.getMqttTopic().equalsIgnoreCase(topicCommand)) {
                    command.execute(json)
                            .onSuccess(response -> {
                                response.ifPresent(resp -> publishResponse(command.getMqttTopic(), resp));
                            })
                            .onFailure(cause -> {
                                Log.error("Failed to publish to topic {}", command.topic());
                                Log.error("Failed to publish: ", cause);
                            });
                }
            }
        });
    }

    private void publishResponse(String topic, JsonObject response) {
        String responseTopic = "response/" + topic;
        client.publish(responseTopic,
                response.toBuffer(),
                MqttQoS.AT_LEAST_ONCE,
                false,
                false
        );
    }
}
