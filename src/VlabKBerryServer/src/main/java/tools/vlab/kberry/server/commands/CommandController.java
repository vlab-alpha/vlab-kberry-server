package tools.vlab.kberry.server.commands;

import io.netty.handler.codec.mqtt.MqttQoS;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.mqtt.MqttClient;
import io.vertx.mqtt.MqttClientOptions;
import io.vertx.mqtt.messages.MqttConnAckMessage;
import lombok.Getter;
import lombok.Setter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import tools.vlab.kberry.core.devices.KNXDevices;
import tools.vlab.kberry.server.logic.Logics;
import tools.vlab.kberry.server.scheduler.Schedule;
import tools.vlab.kberry.server.serviceProvider.ServiceProviders;
import tools.vlab.kberry.server.statistics.Statistics;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class CommandController extends AbstractVerticle {

    private static final Logger Log = LoggerFactory.getLogger(CommandController.class);

    private final String mqttHost;
    private final KNXDevices knxDevices;
    private final Statistics statistics;
    private final ServiceProviders serviceProviders;
    private final Schedule schedule;
    private final Logics logics;
    @Getter
    private final List<Command> commandList = new ArrayList<>();
    @Setter
    @Getter
    private MqttClient client;
    private final int mqttPort;

    public CommandController(String mqttHost, int mqttPort, KNXDevices knxDevices, Statistics statistics, ServiceProviders serviceProviders, Schedule schedule, Logics logics) {
        this.mqttHost = mqttHost;
        this.knxDevices = knxDevices;
        this.statistics = statistics;
        this.serviceProviders = serviceProviders;
        this.schedule = schedule;
        this.logics = logics;
        this.mqttPort = mqttPort;
    }

    public void register(Command command) {
        command.setStatistics(statistics);
        command.setServiceProviders(serviceProviders);
        command.setSchedule(schedule);
        command.setLogics(logics);
        command.setKnxDevices(knxDevices);
        command.init();
        this.commandList.add(command);
    }


    @Override
    public void start(Promise<Void> startPromise) {
        Log.info("Starting CommandController");
        connectClient()
                .onSuccess(v -> {
                    subscribeCommands();
                    setupMessageHandler();
                    startPromise.complete();
                })
                .onFailure(startPromise::fail);
    }

    protected Future<MqttConnAckMessage> connectClient() {
        MqttClientOptions options = new MqttClientOptions()
                .setAutoGeneratedClientId(true)
                .setCleanSession(true);
        this.client = MqttClient.create(getVertx(), options); // <-- Client speichern
        return client.connect(mqttPort, mqttHost); // connect aufrufen
    }

    private void subscribeCommands() {
        Map<String, Integer> subscription = this.commandList.stream()
                .collect(Collectors.toMap(
                        command -> "request/" + command.topic().getTopic(),
                        command -> MqttQoS.EXACTLY_ONCE.value()
                ));
        this.client.subscribe(subscription)
                .onSuccess(handler -> {
                    var result = String.join("\n - ", subscription.keySet());
                    Log.info("Subscribed to: {}\n", result);
                })
                .onFailure(cause -> Log.error("Failed to subscribe to commands! ", cause));
    }

    private void setupMessageHandler() {
        client.publishHandler(message -> {
            String topic = message.topicName();
            if (!topic.startsWith("request/")) return;

            String topicCommand = topic.substring("request/".length());
            var payload = message.payload().toString();
            Log.info("Received {} message: {}", topic, payload);
            JsonObject json = payload != null && !payload.isEmpty() ? new JsonObject(payload) : new JsonObject();
            boolean found = false;
            for (Command command : commandList) {
                if (command instanceof Scene scene && scene.getTopic().equalsIgnoreCase(topicCommand)) {
                    found = true;
                    executeCommand(command, json);
                } else if (command.topic().getTopic().equalsIgnoreCase(topicCommand)) {
                    found = true;
                    executeCommand(command, json);
                }
            }
            if (!found) {
                Log.warn("Unknown topic command {}", topicCommand);
            }
        });
    }

    private void executeCommand(Command command, JsonObject json) {
        command.execute(json)
                .onSuccess(response -> {
                    response.ifPresent(resp -> publishResponse(command.topic().getTopic(), resp));
                })
                .onFailure(cause -> {
                    Log.error("Failed to publish to topic {}", command.topic());
                    Log.error("Failed to publish: ", cause);
                });
    }


    private void publishResponse(String topic, JsonObject response) {
        String responseTopic = "response/" + topic;
        client.publish(responseTopic,
                response.toBuffer(),
                MqttQoS.AT_LEAST_ONCE,
                false,
                false
        );
    }
}
